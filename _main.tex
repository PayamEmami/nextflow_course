% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\title{Introduction to Nextflow}
\author{Payam Emami}
\date{2022-04-11}

\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Introduction to Nextflow},
  pdfauthor={Payam Emami},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{plainnat}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\begin{verbatim}
## Warning: The `path` argument of `write_lines()` is deprecated as of readr 1.4.0.
## Please use the `file` argument instead.
\end{verbatim}

\hypertarget{introduction}{%
\chapter{Introduction}\label{introduction}}

Welcome to this short tutorial on Nextflow. We are going to walk through some of the functionalities of this powerful workflow engine. More specifically we are going to do some hands-on work on processes, channels and operators. We are also going to look into how to configure Nextflow to run on different platforms. But before moving forward, we need to set up the environment for using Nextflow.

\hypertarget{setting-up-the-environment}{%
\section{Setting up the environment}\label{setting-up-the-environment}}

We are going to use UPPMAX for doing most of the handson work.

First ssh to UPPMAX

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{ssh} \AttributeTok{{-}AX}\NormalTok{ youusername@rackham.uppmax.uu.se}
\end{Highlighting}
\end{Shaded}

Make a directory in your user space (only if you have not done before)

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{mkdir} \AttributeTok{{-}p}\NormalTok{ /crex/proj/uppmax2022{-}2{-}10/nobackup/}\VariableTok{$USER}\NormalTok{/nextflow\_lab1}
\end{Highlighting}
\end{Shaded}

Navigate to the folder you have created

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\BuiltInTok{cd}\NormalTok{ /crex/proj/uppmax2022{-}2{-}10/nobackup/}\VariableTok{$USER}\NormalTok{/nextflow\_lab1}
\end{Highlighting}
\end{Shaded}

Load Nexflow

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{module}\NormalTok{ load bioinfo{-}tools}
\ExtensionTok{module}\NormalTok{ load Nextflow/20.10.0}
\end{Highlighting}
\end{Shaded}

If because of any reason, you cannot use UPPMAX, Nextflow can be installed on any POSIX compatible system for example Linux, OS X, Windows Subsystem for Linux. Head to \href{https://www.nextflow.io/docs/latest/getstarted.html\#installation}{Nextflow website} and follow the installation procedure.

\hypertarget{basic-concepts}{%
\chapter{Basic concepts}\label{basic-concepts}}

Nextflow is a reactive workflow framework and a programming DSL that eases the writing of data-intensive computational pipelines.

It is designed around the idea that the Linux platform is the lingua franca of data science. Linux provides many simple but powerful command-line and scripting tools that, when chained together, facilitate complex data manipulations.

Nextflow extends this approach, adding the ability to define complex program interactions and a high-level parallel computational environment based on the dataflow programming model.

\hypertarget{nextflow-scripting}{%
\section{Nextflow scripting}\label{nextflow-scripting}}

The Nextflow scripting language is an extension of the Groovy programming language. Groovy is a powerful programming language for the Java virtual machine. The Nextflow syntax has been specialized to ease the writing of computational pipelines in a declarative manner.

Nextflow can execute any piece of Groovy code or use any library for the JVM platform.

For example,

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\NormalTok{println }\StringTok{"Hello, World!"} \CommentTok{\#1}
 
\NormalTok{x }\OtherTok{=} \DecValTok{1} \CommentTok{\#2}
\NormalTok{println x}
 
\NormalTok{x }\OtherTok{=}\NormalTok{ new }\FunctionTok{java.util.Date}\NormalTok{() }\CommentTok{\#2}
\NormalTok{println x}
 
\NormalTok{x }\OtherTok{=} \SpecialCharTok{{-}}\FloatTok{3.1499392} \CommentTok{\#2}
\NormalTok{println x}
 
\NormalTok{x }\OtherTok{=}\NormalTok{ false }\CommentTok{\#2}
\NormalTok{println x}
 
\NormalTok{x }\OtherTok{=} \StringTok{"Hi"} \CommentTok{\#2}
\NormalTok{println x}

\NormalTok{myList }\OtherTok{=}\NormalTok{ [}\DecValTok{1776}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{99}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{928734928763}\NormalTok{] }\CommentTok{\#3}
\NormalTok{println myList}

\NormalTok{square }\OtherTok{=}\NormalTok{ \{ it }\SpecialCharTok{*}\NormalTok{ it \} }\CommentTok{\#4}
\NormalTok{println }\FunctionTok{square}\NormalTok{(}\DecValTok{9}\NormalTok{)}
 
\NormalTok{printMapClosure }\OtherTok{=}\NormalTok{ \{ key, value }\OtherTok{{-}\textgreater{}}
\NormalTok{   println }\StringTok{"$key = $value"}
\NormalTok{\} }\CommentTok{\#4}

\NormalTok{map\_example}\OtherTok{=}\NormalTok{[ }\StringTok{"Yue"} \SpecialCharTok{:} \StringTok{"Wu"}\NormalTok{, }\StringTok{"Mark"} \SpecialCharTok{:} \StringTok{"Williams"}\NormalTok{, }\StringTok{"Sudha"} \SpecialCharTok{:} \StringTok{"Kumari"}\NormalTok{ ] }\CommentTok{\#5}


\NormalTok{[ }\StringTok{"Yue"} \SpecialCharTok{:} \StringTok{"Wu"}\NormalTok{, }\StringTok{"Mark"} \SpecialCharTok{:} \StringTok{"Williams"}\NormalTok{, }\StringTok{"Sudha"} \SpecialCharTok{:} \StringTok{"Kumari"}\NormalTok{ ]}\FunctionTok{.each}\NormalTok{(printMapClosure) }\CommentTok{\#6}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  To print something is as easy as using one of the print or println methods
\item
  To define a variable, simply assign a value to it
\item
  A List object can be defined by placing the list items in square brackets
\item
  A closure is a block of code that can be passed as an argument to a function. Thus, you can define a chunk of code and then pass it around as if it were a string or an integer
\item
  Maps are used to store associative arrays or dictionaries. They are unordered collections of heterogeneous, named data
\item
  the method Map.each() can take a closure with two arguments, to which it binds the key and the associated value for each key-value pair in the Map
\end{enumerate}

To test this, Create a file called \texttt{main\_2.nf} using your favorite editor (i use nano)

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{nano}\NormalTok{ main\_2.nf}
\end{Highlighting}
\end{Shaded}

Copy and paste the script above. Save the file \texttt{(Ctrl+o\ enter)} and exit \texttt{(Ctrl+x)}
Run the following command:

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{nextflow}\NormalTok{ main\_2.nf}
\end{Highlighting}
\end{Shaded}

There are many other things that can be done with Groovy scripts. Please have a look at \href{https://www.nextflow.io/docs/latest/script.html\#}{Nextflow scripting}

\hypertarget{processes-and-channels}{%
\section{Processes and channels}\label{processes-and-channels}}

In practice a Nextflow pipeline script is made by joining together different \texttt{processes}. Each process can be written in any scripting language that can be executed by the Linux platform (Bash, Perl, Ruby, Python, etc.).

Processes are executed independently and are isolated from each other, i.e.~they do not share a common (writable) state. The only way they can communicate is via asynchronous FIFO queues, called \texttt{channels} in Nextflow.

Any process can define one or more channels as input and output. The interaction between these processes, and ultimately the pipeline execution flow itself, is implicitly defined by these input and output declarations.

\hypertarget{channels}{%
\chapter{Channels}\label{channels}}

We start with \texttt{channels} as they are more resemble the variable in a typical programming language. Nextflow is based on the Dataflow programming model in which processes communicate through channels. Using these channels we can connect different processes together.

There are two different types of channel in Nextflow:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A queue channel is a non-blocking unidirectional FIFO queue which connects two processes or operators. \emph{The same queue channel cannot be used more than one time as}
\item
  A value channel a.k.a. singleton channel by definition is bound to a single value and it can be read unlimited times without consuming its content.
\end{enumerate}

We are going to focus on queue channels here. A queue channel is usually created using a factory method such as a from, fromPath, etc.

\hypertarget{of}{%
\section{of}\label{of}}

The \texttt{of} method allows you to create a channel emitting any sequence of values that are specified as the method argument

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{println} \StringTok{"Channel.of( 1, 3, 5, 7 ):"}
\ExtensionTok{ch}\NormalTok{ = Channel.of}\ErrorTok{(} \ExtensionTok{1,}\NormalTok{ 3, 5, 7 }\KeywordTok{)} \CommentTok{\#1 }
\FunctionTok{ch.view()}

\ExtensionTok{println} \StringTok{"Channel.of( [1, 3, 5, 7, 9]):"}
\ExtensionTok{ch}\NormalTok{ = Channel.of}\ErrorTok{(} \ExtensionTok{[1,}\NormalTok{ 3, 5, 7, 9]}\KeywordTok{)} \CommentTok{\#2}
\FunctionTok{ch.view()}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Creates a channel from a sequence of values and set the name to ch
\item
  Creates a channel from a list of values
\end{enumerate}

Create a file called \texttt{main\_3.nf}

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{nano}\NormalTok{ main\_3.nf}
\end{Highlighting}
\end{Shaded}

Copy the above code to it. Save the file \texttt{(Ctrl+o\ enter)} and exit \texttt{(Ctrl+x)}
Now run

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{nextflow}\NormalTok{ main\_3.nf}
\end{Highlighting}
\end{Shaded}

\hypertarget{frompath}{%
\section{fromPath}\label{frompath}}

You can create a channel emitting one or more file paths by using the fromPath method and specifying a path string as an argument.

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{//}\NormalTok{ single file}
\ExtensionTok{myFileChannel}\NormalTok{ = Channel.fromPath}\ErrorTok{(} \StringTok{\textquotesingle{}/crex/proj/uppmax2022{-}2{-}10/metabolomics/mzMLData/Blank10.mzML\textquotesingle{}} \KeywordTok{)} \CommentTok{\#1}
\FunctionTok{myFileChannel.view()}
\ExtensionTok{//}\NormalTok{ multiple files}
\ExtensionTok{myFileChannel}\NormalTok{ = Channel.fromPath}\ErrorTok{(} \StringTok{\textquotesingle{}/crex/proj/uppmax2022{-}2{-}10/metabolomics/mzMLData/*.*\textquotesingle{}} \KeywordTok{)} \CommentTok{\#2}
\FunctionTok{myFileChannel.view()}
\ExtensionTok{//}\NormalTok{ recursive multiple files}
\ExtensionTok{myFileChannel}\NormalTok{ = Channel.fromPath}\ErrorTok{(} \StringTok{\textquotesingle{}/crex/proj/uppmax2022{-}2{-}10/metabolomics/**.*\textquotesingle{}} \KeywordTok{)} \CommentTok{\#3}
\FunctionTok{myFileChannel.view()}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Creates a channel and binds to it a Path item referring the specified file.
\item
  Whenever the \texttt{fromPath} argument contains a \texttt{*} or \texttt{?} wildcard character it is interpreted as a \texttt{glob} path matcher.
\item
  Two asterisks, i.e.~\texttt{**}, works like \texttt{*} but crosses directory boundaries.
\end{enumerate}

Create a file called \texttt{main\_4.nf}

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{nano}\NormalTok{ main\_4.nf}
\end{Highlighting}
\end{Shaded}

Copy the above code to it. Save the file \texttt{(Ctrl+o\ enter)} and exit \texttt{(Ctrl+x)}
Now run

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{nextflow}\NormalTok{ main\_4.nf}
\end{Highlighting}
\end{Shaded}

There are many parameters as well as channel types that can be used for different purposes. Please check the (documentation){[}\url{https://www.nextflow.io/docs/latest/channel.html}{]}.

\hypertarget{processes}{%
\chapter{Processes}\label{processes}}

In Nextflow a process is the basic processing primitive to execute a user script. As said before, this processes can pretty much run anything from R scripts to complex bash commands. Anything that is executable on the linux system can be run!

The process definition starts with keyword the process, followed by process name and finally the process body delimited by curly brackets. The process body must contain a string which represents the command or, more generally, a script that is executed by it.

The overall structure of a process in Nextflow looks like this:

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\NormalTok{process }\SpecialCharTok{\textless{}}\NormalTok{ name }\SpecialCharTok{\textgreater{}}\NormalTok{ \{}

\NormalTok{   [ directives ] }\CommentTok{\#1}

\NormalTok{   input}\SpecialCharTok{:}
    \ErrorTok{\textless{}}\NormalTok{ process inputs }\SpecialCharTok{\textgreater{}} \CommentTok{\#2}

\NormalTok{   output}\SpecialCharTok{:}
    \ErrorTok{\textless{}}\NormalTok{ process outputs }\SpecialCharTok{\textgreater{}} \CommentTok{\#3}

\NormalTok{   when}\SpecialCharTok{:}
    \ErrorTok{\textless{}}\NormalTok{ condition }\SpecialCharTok{\textgreater{}} \CommentTok{\#4}

\NormalTok{   [script}\SpecialCharTok{|}\NormalTok{shell}\SpecialCharTok{|}\NormalTok{exec]}\SpecialCharTok{:}
   \ErrorTok{\textless{}}\NormalTok{ user script to be executed }\SpecialCharTok{\textgreater{}} \CommentTok{\#5}

\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Using the directive declarations block you can provide optional settings that will affect the execution of the current process
\item
  The input block defines from which channels the process expects to receive data.
\item
  The output declaration block allows you to define the channels used by the process to send out the results produced.
\item
  The \texttt{when} declaration allows you to define a condition that must be verified in order to execute the process.
\item
  The script block is a string statement that defines the command that is executed by the process to carry out its task.
\end{enumerate}

\hypertarget{scriptshellexec}{%
\section{script\textbar shell\textbar exec}\label{scriptshellexec}}

We start with the \texttt{script} block. A process contains one and only one script block, and it must be the last statement when the process contains input and output declarations. The entered string is executed as a Bash script in the host system. It can be any command, script or combination of them, that you would normally use in terminal shell or in a common Bash script. The script block can be a simple string or multi-line string. The latter simplifies the writing of non trivial scripts composed by multiple commands spanning over multiple lines. If you would like to run shell instead of bash you can use single quotation (\texttt{\textquotesingle{}\textquotesingle{}\textquotesingle{}}) instead of double.

For example,

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\VariableTok{db}\OperatorTok{=}\StringTok{\textquotesingle{}database\textquotesingle{}} \CommentTok{\#1}

\ExtensionTok{process}\NormalTok{ justEchoBash \{}
\BuiltInTok{echo}\NormalTok{ true }\CommentTok{\#2}
 \ExtensionTok{script:}
 \StringTok{"""}
\StringTok{ echo }\VariableTok{$db}\StringTok{ \#3}
\StringTok{ """}

\ErrorTok{\}}

\ExtensionTok{process}\NormalTok{ justEchoShell \{}
\BuiltInTok{echo}\NormalTok{ true}
   \ExtensionTok{shell:}
   \StringTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}}
\StringTok{   echo !\{db\} \#4}
\StringTok{   \textquotesingle{}\textquotesingle{}\textquotesingle{}}
\ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Creates a variable and assign it to \texttt{database}.
\item
  This is a directive that is setting the process to print the standard output. More on this later!
\item
  Runs the bash command \texttt{cat} which prints the content of variable \texttt{db}. Note that the variables that you define outside of the process script can be accessed using \texttt{\$} sign
\item
  This is identical to bash but using shell. To access the variable \texttt{db} we need to wrap in \texttt{!\{\}}
\end{enumerate}

Please note that unless really needed try to use \texttt{bash}.

Create a file called \texttt{main\_5.nf}

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{nano}\NormalTok{ main\_5.nf}
\end{Highlighting}
\end{Shaded}

Copy the above code to it. Save the file \texttt{(Ctrl+o\ enter)} and exit \texttt{(Ctrl+x)}
Now run

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{nextflow}\NormalTok{ main\_5.nf}
\end{Highlighting}
\end{Shaded}

\hypertarget{input}{%
\section{input}\label{input}}

The input block defines from which channels the process expects to receive data. You can only define one input block at a time and it must contain one or more input declarations.

The input block follows the syntax shown below:

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{input:}
  \OperatorTok{\textless{}}\NormalTok{input }\ExtensionTok{qualifier}\OperatorTok{\textgreater{}} \OperatorTok{\textless{}}\NormalTok{input name}\OperatorTok{\textgreater{}}\NormalTok{ [from }\OperatorTok{\textless{}}\NormalTok{source channel}\OperatorTok{\textgreater{}}\NormalTok{] [attributes]}
\end{Highlighting}
\end{Shaded}

An input definition starts with an input qualifier and the input name, followed by the keyword from and the actual channel over which inputs are received. Finally some input optional attributes can be specified.

The input qualifier declares the type of data to be received.

The qualifiers available are the ones listed in the following table:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.10}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.90}}@{}}
\toprule
\begin{minipage}[b]{\linewidth}\raggedright
Qualifier
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Semantic
\end{minipage} \\
\midrule
\endhead
val & Lets you access the received input value by its name in the process script. \\
env & Lets you use the received value to set an environment variable named as the specified input name. \\
file & Lets you handle the received value as a file, staging it properly in the execution context. \\
path & Lets you handle the received value as a path, staging the file properly in the execution context. \\
stdin & Lets you forward the received value to the process~stdin~special file. \\
tuple & Lets you handle a group of input values having one of the above qualifiers. \\
each & Lets you execute the process for each entry in the input collection. \\
\bottomrule
\end{longtable}

For example, here we are a channel and a process that gets an input the channel and prits the values.

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{num}\NormalTok{ = Channel.from}\ErrorTok{(} \ExtensionTok{1,}\NormalTok{ 2, 3 }\KeywordTok{)} \CommentTok{\#1}

\ExtensionTok{process}\NormalTok{ basicExample \{}
\BuiltInTok{echo}\NormalTok{ true}
 \ExtensionTok{input:}
 \ExtensionTok{val}\NormalTok{ x from num }\CommentTok{\#2}
 \StringTok{"echo process job }\VariableTok{$x}\StringTok{"} \CommentTok{\#3}
\ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Creates a channel of 1,2,3
\item
  Set the input of the process to the channel \texttt{num}. The type of the channel is \texttt{val}.
\item
  Runs a simple echo command that writes the value to std out! Remember that to access the input we need to use \texttt{\$x}.
\end{enumerate}

In the above example the process is executed three times, each time a value is received from the channel num and used to process the script.

Create a file called \texttt{main\_6.nf}

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{nano}\NormalTok{ main\_6.nf}
\end{Highlighting}
\end{Shaded}

Copy the above code to it. Save the file \texttt{(Ctrl+o\ enter)} and exit \texttt{(Ctrl+x)}
Now run

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{nextflow}\NormalTok{ main\_6.nf}
\end{Highlighting}
\end{Shaded}

Can you create a workflow that reads all the files with \texttt{*.mzML} extension in a file channel and print their name in a process? Remember, this is a file channel!

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{mzMLFiles}\NormalTok{ = Channel.fromPath}\ErrorTok{(} \StringTok{\textquotesingle{}/crex/proj/uppmax2022{-}2{-}10/metabolomics/mzMLData/*.mzML\textquotesingle{}} \KeywordTok{)}

\ExtensionTok{process}\NormalTok{ featureFinder \{}
\BuiltInTok{echo}\NormalTok{ true}
 \ExtensionTok{input:}
 \FunctionTok{file}\NormalTok{ mzML from mzMLFiles}

 \StringTok{"""}
\StringTok{echo i’m processing }\VariableTok{$mzML}\StringTok{ file!}
\StringTok{"""}

\ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

Create a file called \texttt{main\_7.nf} and put write the code.

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{nano}\NormalTok{ main\_7.nf}
\end{Highlighting}
\end{Shaded}

Save the file (Ctrl+o enter) and exit (Ctrl+x). Now run

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{run}\NormalTok{ main\_7.nf}
\end{Highlighting}
\end{Shaded}

\hypertarget{input-each}{%
\subsection{input each}\label{input-each}}

The each qualifier allows you to repeat the execution of a process for each item in a collection, every time a new data is received.

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{mzMLFiles}\NormalTok{ = Channel.fromPath}\ErrorTok{(} \StringTok{\textquotesingle{}/crex/proj/uppmax2022{-}2{-}10/metabolomics/mzMLData/*.mzML\textquotesingle{}} \KeywordTok{)} \CommentTok{\#1}
\ExtensionTok{num}\NormalTok{ = Channel.from}\ErrorTok{(} \ExtensionTok{1,}\NormalTok{ 2, 3 }\KeywordTok{)} \CommentTok{\#2}
\ExtensionTok{process}\NormalTok{ featureFinder \{}
  \BuiltInTok{echo}\NormalTok{ true}
\ExtensionTok{input:}
\ExtensionTok{each}\NormalTok{ x from num }\CommentTok{\#3}
\FunctionTok{file}\NormalTok{ y from mzMLFiles }\CommentTok{\#4}

\StringTok{"echo value }\VariableTok{$x}\StringTok{ file }\VariableTok{$y}\StringTok{"} \CommentTok{\#5}

\ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Creates a file channel from all \texttt{mzML} files in \texttt{/crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.mzML\textquotesingle{}}.\\
\item
  Create a value type channel
\item
  Define input repeater for the value channel
\item
  Define another input channel from the file channel
\end{enumerate}

In the above example every time a file (\texttt{y}) of \texttt{mzML} is received as input by the process, it executes three tasks running a \texttt{echo} with a different value for the x parameter. This is useful when you need to repeat the same task for a given set of parameters.

Create a file called \texttt{main\_8.nf}

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{nano}\NormalTok{ main\_8.nf}
\end{Highlighting}
\end{Shaded}

Copy the above code to it. Save the file \texttt{(Ctrl+o\ enter)} and exit \texttt{(Ctrl+x)}
Now run

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{nextflow}\NormalTok{ main\_8.nf}
\end{Highlighting}
\end{Shaded}

\hypertarget{output}{%
\section{Output}\label{output}}

The output declaration block allows you to define the channels used by the process to send out the results produced. You can only define one output block at a time and it must contain one or more output declarations.

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{output:}
\OperatorTok{\textless{}}\NormalTok{output }\ExtensionTok{qualifier}\OperatorTok{\textgreater{}} \OperatorTok{\textless{}}\NormalTok{output name}\OperatorTok{\textgreater{}}\NormalTok{ [into }\OperatorTok{\textless{}}\NormalTok{target channel}\OperatorTok{\textgreater{}}\NormalTok{[,channel,..]] [attribute [,..]]}
\end{Highlighting}
\end{Shaded}

The qualifiers that can be used in the output declaration block are the ones listed in the following table:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.10}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.90}}@{}}
\toprule
\begin{minipage}[b]{\linewidth}\raggedright
Qualifier
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Semantic
\end{minipage} \\
\midrule
\endhead
val & Sends variables with the name specified over the output channel. \\
file & Sends a file produced by the process with the name specified over the output channel. \\
path & Sends a file produced by the process with the name specified over the output channel (replaces file). \\
env & Sends the variable defined in the process environment with the name specified over the output channel. \\
stdout & Sends the executed process stdout over the output channel. \\
tuple & Sends multiple values over the same output channel. \\
\bottomrule
\end{longtable}

For example,

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{mzMLFiles}\NormalTok{ = Channel.fromPath}\ErrorTok{(} \StringTok{\textquotesingle{}/crex/proj/uppmax2022{-}2{-}10/metabolomics/mzMLData/*.mzML\textquotesingle{}} \KeywordTok{)} \CommentTok{\#1}
\ExtensionTok{process}\NormalTok{ featureFinder \{}
\ExtensionTok{input:}
\FunctionTok{file}\NormalTok{ x from mzMLFiles }\CommentTok{\#2}
\ExtensionTok{output:}
\FunctionTok{file} \StringTok{"output/}\VariableTok{$\{x}\ErrorTok{.baseName}\VariableTok{\}}\StringTok{.featureXML"}\NormalTok{ into outputChannel }\CommentTok{\#3}

\StringTok{""" }
\StringTok{mkdir output }
\StringTok{cp {-}in }\VariableTok{$x}\StringTok{ output/}\VariableTok{$\{x}\ErrorTok{.baseName}\VariableTok{\}}\StringTok{.featureXML }
\StringTok{"""}  \CommentTok{\#5}
\ErrorTok{\}}
\FunctionTok{outputChannel.view()}
\end{Highlighting}
\end{Shaded}

In the above example the process, when executed, it will create a file channel from \texttt{/crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.mzML}. The process will then get this channel as an input and creates an output channel \texttt{outputChannel} where each file extension has been changed to \texttt{featureXML}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Creates a channel emitting files.
\item
  Use the created channel as an input to the process
\item
  create output channel and put the output file in it. The output file is located under \texttt{output} directory. \texttt{\$\{x.baseName\}} gives the name of the file without extension.
\item
  In the bash script, we first create an output folder We then copy the input to the output folder but change its extension. This is obviously a pretty useless command! But you can change this to a more meaningful one!
\end{enumerate}

Create a file called \texttt{main\_9.nf}

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{nano}\NormalTok{ main\_9.nf}
\end{Highlighting}
\end{Shaded}

Copy the above code to it. Save the file \texttt{(Ctrl+o\ enter)} and exit \texttt{(Ctrl+x)}
Now run

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{nextflow}\NormalTok{ main\_9.nf}
\end{Highlighting}
\end{Shaded}

\hypertarget{directives}{%
\section{Directives}\label{directives}}

Using the directive declarations block you can provide optional settings that will affect the execution of the current process.

They must be entered at the top of the process body, before any other declaration blocks (i.e.~input, output, etc) and have the following syntax:

You can see the complete list of directives \href{https://www.nextflow.io/docs/latest/process.html\#directives}{here}

\hypertarget{publishdir}{%
\subsection{publishDir}\label{publishdir}}

The \texttt{publishDir} directive allows you to publish the process output files to a specified folder.

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{process}\NormalTok{ foo \{}

    \ExtensionTok{publishDir} \StringTok{\textquotesingle{}/data/chunks\textquotesingle{}} \CommentTok{\#1}

    \ExtensionTok{output:}
    \FunctionTok{file} \StringTok{\textquotesingle{}chunk\_*\textquotesingle{}}\NormalTok{ into letters}

    \StringTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}}
\StringTok{    printf \textquotesingle{}}\ExtensionTok{Hola}\StringTok{\textquotesingle{} | split {-}b 1 {-} chunk\_}
\StringTok{    \textquotesingle{}\textquotesingle{}\textquotesingle{}}
\ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

The above example splits the string Hola into file chunks of a single byte.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  When complete the chunk\_* output files are published into the /data/chunks folder.
\end{enumerate}

\emph{Can you create a workflow having a single process that just creates a text file (with whatever content) as an output and also publish its output to a directory?}

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{process}\NormalTok{ simpleOutput \{}
\ExtensionTok{publishDir} \StringTok{\textquotesingle{}testOutput\textquotesingle{}}
\ExtensionTok{output:}
\FunctionTok{file} \StringTok{"test.txt"}\NormalTok{ into outputChannel}
\StringTok{"echo test \textgreater{}\textgreater{} test.txt"}

\ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{tag}{%
\subsection{tag}\label{tag}}

The \texttt{tag} directive allows you to associate each process execution with a custom label, so that it will be easier to identify them in the log file or in the trace execution report.

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{mzMLFiles}\NormalTok{ = Channel.fromPath}\ErrorTok{(} \StringTok{\textquotesingle{}/crex/proj/uppmax2022{-}2{-}10/metabolomics/mzMLData/*.mzML\textquotesingle{}} \KeywordTok{)}
\ExtensionTok{num}\NormalTok{ = Channel.from}\ErrorTok{(} \ExtensionTok{1,}\NormalTok{ 2, 3 }\KeywordTok{)}
\ExtensionTok{process}\NormalTok{ featureFinder \{}
\ExtensionTok{tag} \StringTok{"}\VariableTok{$y}\StringTok{"} \CommentTok{\#1}
\ExtensionTok{input:}
\ExtensionTok{each}\NormalTok{ x from num}
\FunctionTok{file}\NormalTok{ y from mzMLFiles}

\StringTok{"""}
\StringTok{echo value }\VariableTok{$x}\StringTok{ file }\VariableTok{$y}
\StringTok{"""}

\ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

In the above example, when a file is received by the process, it will show its name when running the process.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{\$y} in the tag, indicates that name of file from \texttt{mzMLFiles} should be used as tag.
\end{enumerate}

Create a file called \texttt{main\_9.nf}

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{nano}\NormalTok{ main\_12.nf}
\end{Highlighting}
\end{Shaded}

Copy the above code to it. Save the file \texttt{(Ctrl+o\ enter)} and exit \texttt{(Ctrl+x)}
Now run

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{nextflow}\NormalTok{ main\_12.nf}
\end{Highlighting}
\end{Shaded}

What do you see? What is the difference to a process without a tag?

\hypertarget{operators}{%
\chapter{Operators}\label{operators}}

Nextflow operators are methods that allow you to connect channels to each other or to transform values emitted by a channel applying some user provided rules. There is a large number of operators that can be seen \href{https://www.nextflow.io/docs/latest/operator.html}{here}. We go through some of them!

\hypertarget{collect}{%
\section{Collect}\label{collect}}

The \texttt{collect} operator collects all the items emitted by a channel to a List and return the resulting object as a \emph{sole} emission.

For example,

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{mzMLFiles}\NormalTok{ = Channel.fromPath}\ErrorTok{(} \StringTok{\textquotesingle{}/crex/proj/uppmax2022{-}2{-}10/metabolomics/mzMLData/*.mzML\textquotesingle{}} \KeywordTok{)}
\FunctionTok{mzMLFiles.collect().view()}
\end{Highlighting}
\end{Shaded}

The above code, will get the files from the path and emit them all at once. You can try this and compare the results to when you don't use collect.

Create a file called \texttt{main\_13.nf}

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\FunctionTok{nano}\NormalTok{ main\_13.nf}
\end{Highlighting}
\end{Shaded}

Copy the above code to it. Save the file \texttt{(Ctrl+o\ enter)} and exit \texttt{(Ctrl+x)}
Now run

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{nextflow}\NormalTok{ main\_13.nf}
\end{Highlighting}
\end{Shaded}

This operator can also be used inside the process. For example,

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{mzMLFiles}\NormalTok{ = Channel.fromPath}\ErrorTok{(} \StringTok{\textquotesingle{}/crex/proj/uppmax2022{-}2{-}10/metabolomics/mzMLData/*.mzML\textquotesingle{}} \KeywordTok{)}
\ExtensionTok{process}\NormalTok{ featureFinder \{}
\ExtensionTok{input:}
\FunctionTok{file}\NormalTok{ x from mzMLFiles.collect}\ErrorTok{(}\KeywordTok{)} \CommentTok{\#1}

\StringTok{""" }
\StringTok{echo }\VariableTok{$x}
\StringTok{"""}  
\ErrorTok{\}}
\FunctionTok{outputChannel.view()}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  By using \texttt{collect()}, the process will gather all the files in \texttt{mzMLFiles} channel and do the operation for this collection of files.
\end{enumerate}

Run this example and compare the results to when you don't use collect. What is the difference? How many times the process will be run if you use and don't use collect?

\hypertarget{flatten}{%
\section{flatten}\label{flatten}}

The \texttt{flatten} operator transforms a channel in such a way that every item of type Collection or \texttt{Array} is flattened so that each single entry is emitted separately by the resulting channel.

for example,

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\ExtensionTok{Channel}
    \ExtensionTok{.from}\ErrorTok{(} \ExtensionTok{[1,[2,3]],}\NormalTok{ 4, [5,[6]] }\KeywordTok{)}
    \FunctionTok{.flatten()}
    \FunctionTok{.view()}
\end{Highlighting}
\end{Shaded}

Try to run this example and compare the results to collect!

\hypertarget{configuration-file}{%
\chapter{Configuration file}\label{configuration-file}}

\end{document}
