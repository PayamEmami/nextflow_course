[["index.html", "Introduction to Nextflow Chapter 1 Introduction 1.1 Setting up the environment", " Introduction to Nextflow Payam Emami 2022-04-11 Chapter 1 Introduction Welcome to this short tutorial on Nextflow. We are going to walk through some of the functionalities of this powerful workflow engine. More specifically we are going to do some hands-on work on processes, channels and operators. We are also going to look into how to configure Nextflow to run on different platforms. But before moving forward, we need to set up the environment for using Nextflow. 1.1 Setting up the environment We are going to use UPPMAX for doing most of the handson work. First ssh to UPPMAX ssh -AX youusername@rackham.uppmax.uu.se Make a directory in your user space (only if you have not done before) mkdir -p /crex/proj/uppmax2022-2-10/nobackup/$USER/nextflow_lab1 Navigate to the folder you have created cd /crex/proj/uppmax2022-2-10/nobackup/$USER/nextflow_lab1 Load Nexflow module load bioinfo-tools module load Nextflow/20.10.0 If because of any reason, you cannot use UPPMAX, Nextflow can be installed on any POSIX compatible system for example Linux, OS X, Windows Subsystem for Linux. Head to Nextflow website and follow the installation procedure. "],["basic-concepts.html", "Chapter 2 Basic concepts 2.1 Nextflow scripting 2.2 Processes and channels", " Chapter 2 Basic concepts Nextflow is a reactive workflow framework and a programming DSL that eases the writing of data-intensive computational pipelines. It is designed around the idea that the Linux platform is the lingua franca of data science. Linux provides many simple but powerful command-line and scripting tools that, when chained together, facilitate complex data manipulations. Nextflow extends this approach, adding the ability to define complex program interactions and a high-level parallel computational environment based on the dataflow programming model. 2.1 Nextflow scripting The Nextflow scripting language is an extension of the Groovy programming language. Groovy is a powerful programming language for the Java virtual machine. The Nextflow syntax has been specialized to ease the writing of computational pipelines in a declarative manner. Nextflow can execute any piece of Groovy code or use any library for the JVM platform. For example, println &quot;Hello, World!&quot; #1 x = 1 #2 println x x = new java.util.Date() #2 println x x = -3.1499392 #2 println x x = false #2 println x x = &quot;Hi&quot; #2 println x myList = [1776, -1, 33, 99, 0, 928734928763] #3 println myList square = { it * it } #4 println square(9) printMapClosure = { key, value -&gt; println &quot;$key = $value&quot; } #4 map_example=[ &quot;Yue&quot; : &quot;Wu&quot;, &quot;Mark&quot; : &quot;Williams&quot;, &quot;Sudha&quot; : &quot;Kumari&quot; ] #5 [ &quot;Yue&quot; : &quot;Wu&quot;, &quot;Mark&quot; : &quot;Williams&quot;, &quot;Sudha&quot; : &quot;Kumari&quot; ].each(printMapClosure) #6 To print something is as easy as using one of the print or println methods To define a variable, simply assign a value to it A List object can be defined by placing the list items in square brackets A closure is a block of code that can be passed as an argument to a function. Thus, you can define a chunk of code and then pass it around as if it were a string or an integer Maps are used to store associative arrays or dictionaries. They are unordered collections of heterogeneous, named data the method Map.each() can take a closure with two arguments, to which it binds the key and the associated value for each key-value pair in the Map To test this, Create a file called main_2.nf using your favorite editor (i use nano) nano main_2.nf Copy and paste the script above. Save the file (Ctrl+o enter) and exit (Ctrl+x) Run the following command: nextflow main_2.nf There are many other things that can be done with Groovy scripts. Please have a look at Nextflow scripting 2.2 Processes and channels In practice a Nextflow pipeline script is made by joining together different processes. Each process can be written in any scripting language that can be executed by the Linux platform (Bash, Perl, Ruby, Python, etc.). Processes are executed independently and are isolated from each other, i.e. they do not share a common (writable) state. The only way they can communicate is via asynchronous FIFO queues, called channels in Nextflow. Any process can define one or more channels as input and output. The interaction between these processes, and ultimately the pipeline execution flow itself, is implicitly defined by these input and output declarations. "],["channels.html", "Chapter 3 Channels 3.1 of 3.2 fromPath", " Chapter 3 Channels We start with channels as they are more resemble the variable in a typical programming language. Nextflow is based on the Dataflow programming model in which processes communicate through channels. Using these channels we can connect different processes together. There are two different types of channel in Nextflow: A queue channel is a non-blocking unidirectional FIFO queue which connects two processes or operators. The same queue channel cannot be used more than one time as A value channel a.k.a. singleton channel by definition is bound to a single value and it can be read unlimited times without consuming its content. We are going to focus on queue channels here. A queue channel is usually created using a factory method such as a from, fromPath, etc. 3.1 of The of method allows you to create a channel emitting any sequence of values that are specified as the method argument println &quot;Channel.of( 1, 3, 5, 7 ):&quot; ch = Channel.of( 1, 3, 5, 7 ) #1 ch.view() println &quot;Channel.of( [1, 3, 5, 7, 9]):&quot; ch = Channel.of( [1, 3, 5, 7, 9]) #2 ch.view() Creates a channel from a sequence of values and set the name to ch Creates a channel from a list of values Create a file called main_3.nf nano main_3.nf Copy the above code to it. Save the file (Ctrl+o enter) and exit (Ctrl+x) Now run nextflow main_3.nf 3.2 fromPath You can create a channel emitting one or more file paths by using the fromPath method and specifying a path string as an argument. // single file myFileChannel = Channel.fromPath( &#39;/crex/proj/uppmax2022-2-10/metabolomics/mzMLData/Blank10.mzML&#39; ) #1 myFileChannel.view() // multiple files myFileChannel = Channel.fromPath( &#39;/crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.*&#39; ) #2 myFileChannel.view() // recursive multiple files myFileChannel = Channel.fromPath( &#39;/crex/proj/uppmax2022-2-10/metabolomics/**.*&#39; ) #3 myFileChannel.view() Creates a channel and binds to it a Path item referring the specified file. Whenever the fromPath argument contains a * or ? wildcard character it is interpreted as a glob path matcher. Two asterisks, i.e. **, works like * but crosses directory boundaries. Create a file called main_4.nf nano main_4.nf Copy the above code to it. Save the file (Ctrl+o enter) and exit (Ctrl+x) Now run nextflow main_4.nf There are many parameters as well as channel types that can be used for different purposes. Please check the (documentation)[https://www.nextflow.io/docs/latest/channel.html]. "],["processes.html", "Chapter 4 Processes 4.1 script|shell|exec 4.2 input 4.3 Output 4.4 Directives", " Chapter 4 Processes In Nextflow a process is the basic processing primitive to execute a user script. As said before, this processes can pretty much run anything from R scripts to complex bash commands. Anything that is executable on the linux system can be run! The process definition starts with keyword the process, followed by process name and finally the process body delimited by curly brackets. The process body must contain a string which represents the command or, more generally, a script that is executed by it. The overall structure of a process in Nextflow looks like this: process &lt; name &gt; { [ directives ] #1 input: &lt; process inputs &gt; #2 output: &lt; process outputs &gt; #3 when: &lt; condition &gt; #4 [script|shell|exec]: &lt; user script to be executed &gt; #5 } Using the directive declarations block you can provide optional settings that will affect the execution of the current process The input block defines from which channels the process expects to receive data. The output declaration block allows you to define the channels used by the process to send out the results produced. The when declaration allows you to define a condition that must be verified in order to execute the process. The script block is a string statement that defines the command that is executed by the process to carry out its task. 4.1 script|shell|exec We start with the script block. A process contains one and only one script block, and it must be the last statement when the process contains input and output declarations. The entered string is executed as a Bash script in the host system. It can be any command, script or combination of them, that you would normally use in terminal shell or in a common Bash script. The script block can be a simple string or multi-line string. The latter simplifies the writing of non trivial scripts composed by multiple commands spanning over multiple lines. If you would like to run shell instead of bash you can use single quotation (''') instead of double. For example, db=&#39;database&#39; #1 process justEchoBash { echo true #2 script: &quot;&quot;&quot; echo $db #3 &quot;&quot;&quot; } process justEchoShell { echo true shell: &#39;&#39;&#39; echo !{db} #4 &#39;&#39;&#39; } Creates a variable and assign it to database. This is a directive that is setting the process to print the standard output. More on this later! Runs the bash command cat which prints the content of variable db. Note that the variables that you define outside of the process script can be accessed using $ sign This is identical to bash but using shell. To access the variable db we need to wrap in !{} Please note that unless really needed try to use bash. Create a file called main_5.nf nano main_5.nf Copy the above code to it. Save the file (Ctrl+o enter) and exit (Ctrl+x) Now run nextflow main_5.nf 4.2 input The input block defines from which channels the process expects to receive data. You can only define one input block at a time and it must contain one or more input declarations. The input block follows the syntax shown below: input: &lt;input qualifier&gt; &lt;input name&gt; [from &lt;source channel&gt;] [attributes] An input definition starts with an input qualifier and the input name, followed by the keyword from and the actual channel over which inputs are received. Finally some input optional attributes can be specified. The input qualifier declares the type of data to be received. The qualifiers available are the ones listed in the following table: Qualifier Semantic val Lets you access the received input value by its name in the process script. env Lets you use the received value to set an environment variable named as the specified input name. file Lets you handle the received value as a file, staging it properly in the execution context. path Lets you handle the received value as a path, staging the file properly in the execution context. stdin Lets you forward the received value to the process stdin special file. tuple Lets you handle a group of input values having one of the above qualifiers. each Lets you execute the process for each entry in the input collection. For example, here we are a channel and a process that gets an input the channel and prits the values. num = Channel.from( 1, 2, 3 ) #1 process basicExample { echo true input: val x from num #2 &quot;echo process job $x&quot; #3 } Creates a channel of 1,2,3 Set the input of the process to the channel num. The type of the channel is val. Runs a simple echo command that writes the value to std out! Remember that to access the input we need to use $x. In the above example the process is executed three times, each time a value is received from the channel num and used to process the script. Create a file called main_6.nf nano main_6.nf Copy the above code to it. Save the file (Ctrl+o enter) and exit (Ctrl+x) Now run nextflow main_6.nf Can you create a workflow that reads all the files with *.mzML extension in a file channel and print their name in a process? Remember, this is a file channel! mzMLFiles = Channel.fromPath( &#39;/crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.mzML&#39; ) process featureFinder { echo true input: file mzML from mzMLFiles &quot;&quot;&quot; echo i’m processing $mzML file! &quot;&quot;&quot; } Create a file called main_7.nf and put write the code. nano main_7.nf Save the file (Ctrl+o enter) and exit (Ctrl+x). Now run run main_7.nf 4.2.1 input each The each qualifier allows you to repeat the execution of a process for each item in a collection, every time a new data is received. mzMLFiles = Channel.fromPath( &#39;/crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.mzML&#39; ) #1 num = Channel.from( 1, 2, 3 ) #2 process featureFinder { echo true input: each x from num #3 file y from mzMLFiles #4 &quot;echo value $x file $y&quot; #5 } Creates a file channel from all mzML files in /crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.mzML'. Create a value type channel Define input repeater for the value channel Define another input channel from the file channel In the above example every time a file (y) of mzML is received as input by the process, it executes three tasks running a echo with a different value for the x parameter. This is useful when you need to repeat the same task for a given set of parameters. Create a file called main_8.nf nano main_8.nf Copy the above code to it. Save the file (Ctrl+o enter) and exit (Ctrl+x) Now run nextflow main_8.nf 4.3 Output The output declaration block allows you to define the channels used by the process to send out the results produced. You can only define one output block at a time and it must contain one or more output declarations. output: &lt;output qualifier&gt; &lt;output name&gt; [into &lt;target channel&gt;[,channel,..]] [attribute [,..]] The qualifiers that can be used in the output declaration block are the ones listed in the following table: Qualifier Semantic val Sends variables with the name specified over the output channel. file Sends a file produced by the process with the name specified over the output channel. path Sends a file produced by the process with the name specified over the output channel (replaces file). env Sends the variable defined in the process environment with the name specified over the output channel. stdout Sends the executed process stdout over the output channel. tuple Sends multiple values over the same output channel. For example, mzMLFiles = Channel.fromPath( &#39;/crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.mzML&#39; ) #1 process featureFinder { input: file x from mzMLFiles #2 output: file &quot;output/${x.baseName}.featureXML&quot; into outputChannel #3 &quot;&quot;&quot; mkdir output cp -in $x output/${x.baseName}.featureXML &quot;&quot;&quot; #5 } outputChannel.view() In the above example the process, when executed, it will create a file channel from /crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.mzML. The process will then get this channel as an input and creates an output channel outputChannel where each file extension has been changed to featureXML. Creates a channel emitting files. Use the created channel as an input to the process create output channel and put the output file in it. The output file is located under output directory. ${x.baseName} gives the name of the file without extension. In the bash script, we first create an output folder We then copy the input to the output folder but change its extension. This is obviously a pretty useless command! But you can change this to a more meaningful one! Create a file called main_9.nf nano main_9.nf Copy the above code to it. Save the file (Ctrl+o enter) and exit (Ctrl+x) Now run nextflow main_9.nf 4.4 Directives Using the directive declarations block you can provide optional settings that will affect the execution of the current process. They must be entered at the top of the process body, before any other declaration blocks (i.e. input, output, etc) and have the following syntax: You can see the complete list of directives here 4.4.1 publishDir The publishDir directive allows you to publish the process output files to a specified folder. process foo { publishDir &#39;/data/chunks&#39; #1 output: file &#39;chunk_*&#39; into letters &#39;&#39;&#39; printf &#39;Hola&#39; | split -b 1 - chunk_ &#39;&#39;&#39; } The above example splits the string Hola into file chunks of a single byte. When complete the chunk_* output files are published into the /data/chunks folder. Can you create a workflow having a single process that just creates a text file (with whatever content) as an output and also publish its output to a directory? process simpleOutput { publishDir &#39;testOutput&#39; output: file &quot;test.txt&quot; into outputChannel &quot;echo test &gt;&gt; test.txt&quot; } 4.4.2 tag The tag directive allows you to associate each process execution with a custom label, so that it will be easier to identify them in the log file or in the trace execution report. mzMLFiles = Channel.fromPath( &#39;/crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.mzML&#39; ) num = Channel.from( 1, 2, 3 ) process featureFinder { tag &quot;$y&quot; #1 input: each x from num file y from mzMLFiles &quot;&quot;&quot; echo value $x file $y &quot;&quot;&quot; } In the above example, when a file is received by the process, it will show its name when running the process. $y in the tag, indicates that name of file from mzMLFiles should be used as tag. Create a file called main_9.nf nano main_12.nf Copy the above code to it. Save the file (Ctrl+o enter) and exit (Ctrl+x) Now run nextflow main_12.nf What do you see? What is the difference to a process without a tag? "],["operators.html", "Chapter 5 Operators 5.1 Collect 5.2 flatten", " Chapter 5 Operators Nextflow operators are methods that allow you to connect channels to each other or to transform values emitted by a channel applying some user provided rules. There is a large number of operators that can be seen here. We go through some of them! 5.1 Collect The collect operator collects all the items emitted by a channel to a List and return the resulting object as a sole emission. For example, mzMLFiles = Channel.fromPath( &#39;/crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.mzML&#39; ) mzMLFiles.collect().view() The above code, will get the files from the path and emit them all at once. You can try this and compare the results to when you don’t use collect. Create a file called main_13.nf nano main_13.nf Copy the above code to it. Save the file (Ctrl+o enter) and exit (Ctrl+x) Now run nextflow main_13.nf This operator can also be used inside the process. For example, mzMLFiles = Channel.fromPath( &#39;/crex/proj/uppmax2022-2-10/metabolomics/mzMLData/*.mzML&#39; ) process featureFinder { input: file x from mzMLFiles.collect() #1 &quot;&quot;&quot; echo $x &quot;&quot;&quot; } outputChannel.view() By using collect(), the process will gather all the files in mzMLFiles channel and do the operation for this collection of files. Run this example and compare the results to when you don’t use collect. What is the difference? How many times the process will be run if you use and don’t use collect? 5.2 flatten The flatten operator transforms a channel in such a way that every item of type Collection or Array is flattened so that each single entry is emitted separately by the resulting channel. for example, Channel .from( [1,[2,3]], 4, [5,[6]] ) .flatten() .view() Try to run this example and compare the results to collect! "],["configuration-file.html", "Chapter 6 Configuration file", " Chapter 6 Configuration file "]]
